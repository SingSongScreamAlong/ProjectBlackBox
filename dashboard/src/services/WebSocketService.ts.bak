import { io, Socket } from 'socket.io-client';
import { v4 as uuidv4 } from 'uuid';
import websocketMessageValidator from '../utils/validation/websocketMessageValidator';

export interface TelemetryData {
  // Driver identification for multi-driver support
  driverId?: string;
  driverName?: string;
  speed: number;
  rpm: number;
  gear: number;
  throttle: number;
  brake: number;
  steering: number;
  tires: {
    frontLeft: { temp: number; wear: number; pressure: number };
    frontRight: { temp: number; wear: number; pressure: number };
    rearLeft: { temp: number; wear: number; pressure: number };
    rearRight: { temp: number; wear: number; pressure: number };
  };
  position: { x: number; y: number; z: number };
  lap: number;
  sector: number;
  lapTime: number;
  sectorTime: number;
  bestLapTime: number;
  bestSectorTimes: number[];
  gForce: { lateral: number; longitudinal: number; vertical: number };
  trackPosition: number;
  racePosition: number;
  gapAhead: number;
  gapBehind: number;
  timestamp: number;
}

export interface DriverProfile {
  id: string;
  name: string;
  team: string;
  role: 'primary' | 'secondary' | 'reserve';
  status: 'active' | 'standby' | 'offline';
  avatar?: string;
  preferences?: {
    displayUnits: 'metric' | 'imperial';
    telemetryHighlights: string[];
    uiTheme: 'default' | 'high-contrast' | 'custom';
    customColors?: Record<string, string>;
  };
  stats?: {
    totalLaps: number;
    bestLap: number;
    consistencyRating: number;
    lastActive: number; // timestamp
  };
}

export interface SessionInfo {
  track: string;
  session: string;
  driver: string;
  car: string;
  weather: {
    temperature: number;
    trackTemperature: number;
    windSpeed: number;
    windDirection: string;
    humidity: number;
    trackGrip: number;
  };
  totalLaps: number;
  sessionTime: number;
  remainingTime: number;
}

export interface CoachingInsight {
  priority: 'critical' | 'high' | 'medium' | 'low';
  confidence: number;
  title: string;
  description: string;
  impact: string;
  location?: string;
  category?: string;
}

export interface DriverSkillAnalysis {
  strengths: Array<{ skill: string; rating: number }>;
  focusAreas: Array<{ skill: string; rating: number }>;
  overallRating: number;
}

export interface CompetitorData {
  position: number;
  driver: string;
  gap: string;
  lastLap: string;
}

export interface StrategyData {
  pitWindow: string;
  optimalPit: string;
  tireStrategy: string;
  fuelStrategy: string;
  paceTarget: string;
  positionPrediction: string;
  undercutRisk: string;
  tireLife: number;
}

// Multi-driver event interfaces
export interface DriverUpdateEvent {
  driver: {
    id: string;
    name: string;
    status: 'active' | 'standby' | 'offline';
    [key: string]: any; // Other driver properties
  };
}

export interface DriverListEvent {
  drivers: Array<{
    id: string;
    name: string;
    team: string;
    role: string;
    status: 'active' | 'standby' | 'offline';
    [key: string]: any; // Other driver properties
  }>;
  activeDriverId: string;
}

export interface HandoffRequestEvent {
  handoff: {
    id: string;
    fromDriverId: string;
    toDriverId: string;
    notes: string;
    timestamp: number;
    status: 'pending';
  };
}

export interface HandoffResponseEvent {
  handoffId: string;
  status: 'confirmed' | 'cancelled' | 'completed';
}

export interface SwitchDriverEvent {
  driverId: string;
}

export interface TeamMessageEvent {
  message: {
    id: string;
    senderId: string;
    senderName: string;
    timestamp: number;
    content: string;
    priority: 'normal' | 'high' | 'critical';
  };
}

export interface RequestComparisonEvent {
  driverAId: string;
  driverBId: string;
  comparisonId: string;
}

export interface ComparisonResultEvent {
  comparisonId: string;
  metrics: Array<{
    name: string;
    driverA: {
      value: string | number;
      delta: number;
    };
    driverB: {
      value: string | number;
      delta: number;
    };
  }>;
}

type EventCallback<T> = (data: T) => void;

// Connection types supported by the service
export enum ConnectionType {
  SOCKET_IO = 'socket_io',
  NATIVE_WEBSOCKET = 'native_websocket'
}

class WebSocketService {
  private static instance: WebSocketService;
  private socket: Socket | null = null;
  private nativeWs: WebSocket | null = null;
  private connectionType: ConnectionType = ConnectionType.SOCKET_IO;
  private connected: boolean = false;
  
  // Event callbacks
  private telemetryCallbacks: EventCallback<TelemetryData>[] = [];
  private sessionCallbacks: EventCallback<SessionInfo>[] = [];
  private coachingCallbacks: EventCallback<CoachingInsight[]>[] = [];
  private skillAnalysisCallbacks: EventCallback<DriverSkillAnalysis>[] = [];
  private competitorCallbacks: EventCallback<CompetitorData[]>[] = [];
  private strategyCallbacks: EventCallback<StrategyData>[] = [];
  private trackPositionCallbacks: EventCallback<any>[] = [];
  private videoDataCallbacks: Array<EventCallback<any>> = [];
  private validationCallbacks: Array<EventCallback<any>> = [];
  private eventCallbacks: Map<string, Array<EventCallback<any>>> = new Map();
  
  // Multi-driver event callbacks
  private driverUpdateCallbacks: EventCallback<DriverUpdateEvent>[] = [];
  private driverListCallbacks: EventCallback<DriverListEvent>[] = [];
  private handoffRequestCallbacks: EventCallback<HandoffRequestEvent>[] = [];
  private handoffResponseCallbacks: EventCallback<HandoffResponseEvent>[] = [];
  private switchDriverCallbacks: EventCallback<SwitchDriverEvent>[] = [];
  private teamMessageCallbacks: EventCallback<TeamMessageEvent>[] = [];
  private requestComparisonCallbacks: EventCallback<RequestComparisonEvent>[] = [];
  private comparisonResultCallbacks: EventCallback<ComparisonResultEvent>[] = [];
  
  // Event callbacks for connect/disconnect
  private connectCallbacks: EventCallback<void>[] = [];
  private disconnectCallbacks: EventCallback<void>[] = [];
  
  // Singleton pattern
  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }

  // Generic event handler with overloads
  on(event: 'connect', callback: EventCallback<void>): () => void;
  on(event: 'disconnect', callback: EventCallback<void>): () => void;
  on(event: 'telemetry', callback: EventCallback<TelemetryData>): () => void;
  on(event: 'session_info', callback: EventCallback<SessionInfo>): () => void;
  on(event: 'coaching', callback: EventCallback<CoachingInsight[]>): () => void;
  on(event: 'skill_analysis', callback: EventCallback<DriverSkillAnalysis>): () => void;
  on(event: 'competitor_data', callback: EventCallback<CompetitorData[]>): () => void;
  on(event: 'strategy_data', callback: EventCallback<StrategyData>): () => void;
  on(event: 'validation_summary', callback: EventCallback<any>): () => void;
  on(event: 'track_position', callback: EventCallback<any>): () => void;
  on(event: 'video_data', callback: EventCallback<any>): () => void;
  
  // Multi-driver event handlers
  on(event: 'driver_update', callback: EventCallback<DriverUpdateEvent>): () => void;
  on(event: 'driver_list', callback: EventCallback<DriverListEvent>): () => void;
  on(event: 'handoff_request', callback: EventCallback<HandoffRequestEvent>): () => void;
  on(event: 'handoff_response', callback: EventCallback<HandoffResponseEvent>): () => void;
  on(event: 'switch_driver', callback: EventCallback<SwitchDriverEvent>): () => void;
  on(event: 'team_message', callback: EventCallback<TeamMessageEvent>): () => void;
  on(event: 'request_comparison', callback: EventCallback<RequestComparisonEvent>): () => void;
  on(event: 'comparison_result', callback: EventCallback<ComparisonResultEvent>): () => void;
  on(event: string, callback: EventCallback<any>): () => void {
    switch (event) {
      case 'telemetry':
        return this.onTelemetry(callback as EventCallback<TelemetryData>);
      case 'session_info':
        return this.onSessionInfo(callback as EventCallback<SessionInfo>);
      case 'coaching':
        return this.onCoachingInsights(callback as EventCallback<CoachingInsight[]>);
      case 'skill_analysis':
        return this.onDriverSkillAnalysis(callback as EventCallback<DriverSkillAnalysis>);
      case 'competitor_data':
        return this.onCompetitorData(callback as EventCallback<CompetitorData[]>);
      case 'strategy_data':
        return this.onStrategyData(callback as EventCallback<StrategyData>);
      case 'track_position':
        this.trackPositionCallbacks.push(callback);
        return () => {
          this.trackPositionCallbacks = this.trackPositionCallbacks.filter(cb => cb !== callback);
        };
      case 'video_data':
        this.videoDataCallbacks.push(callback);
        return () => {
          this.videoDataCallbacks = this.videoDataCallbacks.filter(cb => cb !== callback);
        };
      case 'validation_summary':
        this.validationCallbacks.push(callback);
        return () => {
          this.validationCallbacks = this.validationCallbacks.filter(cb => cb !== callback);
        };
      case 'connect':
        this.connectCallbacks.push(callback as EventCallback<void>);
        return () => {
          this.connectCallbacks = this.connectCallbacks.filter(cb => cb !== callback);
        };
      case 'disconnect':
        this.disconnectCallbacks.push(callback as EventCallback<void>);
        return () => {
          this.disconnectCallbacks = this.disconnectCallbacks.filter(cb => cb !== callback);
        };
      default:
        console.warn(`Unhandled event type in on(): ${event}`);
        return () => {};
    }
  }
  
  // Generic event unsubscribe
  off(event: string, callback: EventCallback<any>): void {
    switch (event) {
      case 'connect':
        this.connectCallbacks = this.connectCallbacks.filter(cb => cb !== callback);
        break;
      case 'disconnect':
        this.disconnectCallbacks = this.disconnectCallbacks.filter(cb => cb !== callback);
        break;
      case 'telemetry':
        this.telemetryCallbacks = this.telemetryCallbacks.filter(cb => cb !== callback);
        break;
      case 'session_info':
        this.sessionCallbacks = this.sessionCallbacks.filter(cb => cb !== callback);
        break;
      case 'coaching':
        this.coachingCallbacks = this.coachingCallbacks.filter(cb => cb !== callback);
        break;
      case 'skill_analysis':
        this.skillAnalysisCallbacks = this.skillAnalysisCallbacks.filter(cb => cb !== callback);
        break;
      case 'competitor_data':
        this.competitorCallbacks = this.competitorCallbacks.filter(cb => cb !== callback);
        break;
      case 'strategy_data':
        this.strategyCallbacks = this.strategyCallbacks.filter(cb => cb !== callback);
        break;
      default:
        console.warn(`Unhandled event type in off(): ${event}`);
    }
  }
  
  /**
   * Connect to a WebSocket server using either Socket.io or native WebSocket
   * @param url The URL to connect to
   * @param type The type of connection to use (Socket.io or native WebSocket)
   */
  connect(url: string = 'http://localhost:3001', type: ConnectionType = ConnectionType.SOCKET_IO): void {
    // Disconnect any existing connections
    this.disconnect();
    
    this.connectionType = type;
    
    if (type === ConnectionType.SOCKET_IO) {
      this.connectSocketIO(url);
    } else {
      this.connectNativeWebSocket(url);
    }
  }
  
  /**
   * Connect using Socket.io
   */
  private connectSocketIO(url: string): void {
    console.log(`Connecting to Socket.io server at ${url}`);
    this.socket = io(url);

    this.socket.on('connect', () => {
      console.log('Connected to Socket.io server');
      this.connected = true;
      this.connectCallbacks.forEach(callback => callback());
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from Socket.io server');
      this.connected = false;
      this.disconnectCallbacks.forEach(callback => callback());
    });

    this.socket.on('telemetry', (data: TelemetryData) => {
      this.telemetryCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('session_info', (data: SessionInfo) => {
      this.sessionCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('coaching', (data: CoachingInsight[]) => {
      this.coachingCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('skill_analysis', (data: DriverSkillAnalysis) => {
      this.skillAnalysisCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('competitor_data', (data: CompetitorData[]) => {
      this.competitorCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('strategy_data', (data: StrategyData) => {
      this.strategyCallbacks.forEach(callback => callback(data));
    });

    this.socket.on('error', (error: any) => {
      console.error('Socket.io error:', error);
    });
  }
  
  /**
   * Connect using native WebSocket
   */
  private connectNativeWebSocket(url: string): void {
    console.log(`Connecting to native WebSocket server at ${url}`);
    this.nativeWs = new WebSocket(url);
    
    this.nativeWs.onopen = () => {
      console.log('Connected to native WebSocket server');
      this.connectCallbacks.forEach(callback => callback());
    };
    
    this.nativeWs.onclose = () => {
      console.log('Disconnected from native WebSocket server');
      this.disconnectCallbacks.forEach(callback => callback());
    };
    
    this.nativeWs.onerror = (error) => {
      console.error('Native WebSocket error:', error);
    };
    
    this.nativeWs.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        const { type, data } = message;
        
        try {
          switch (type) {
            case 'telemetry':
              this.telemetryCallbacks.forEach(callback => callback(data));
              break;
            case 'session_info':
              this.sessionCallbacks.forEach(callback => callback(data));
              break;
            case 'coaching':
              this.coachingCallbacks.forEach(callback => callback(data));
              break;
            case 'skill_analysis':
              this.skillAnalysisCallbacks.forEach(callback => callback(data));
              break;
            case 'competitor_data':
              this.competitorCallbacks.forEach(callback => callback(data));
              break;
            case 'strategy_data':
              this.strategyCallbacks.forEach(callback => callback(data));
              break;
            case 'track_position':
              this.trackPositionCallbacks.forEach(callback => callback(data));
              break;
            case 'video_data':
              this.videoDataCallbacks.forEach(callback => callback(data));
              break;
            case 'validation_summary':
              this.validationCallbacks.forEach(callback => callback(data));
              break;
            case 'connect':
              console.log('Received connect confirmation:', data);
              break;
            default:
              // Try to handle unknown message types by event name
              if (this.eventCallbacks.has(type)) {
                const callbacks = this.eventCallbacks.get(type) || [];
                callbacks.forEach(callback => callback(data));
              } else {
                console.warn(`Unhandled message type: ${type}`);
              }
          }  
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      } catch (error) {
        console.error('Error parsing WebSocket message:', error);
      }
    };
  }

  /**
   * Send a message over the WebSocket connection with validation and sanitization
   * @param eventName The message type/event name
   * @param payload The message data/payload
   * @returns boolean True if message was sent successfully, false otherwise
   */
  sendMessage(eventName: string, payload: any): boolean {
    try {
      // Only validate messages for team communication, not relay agent messages
      // Relay agent messages use a different format and don't need the same validation
      if (!eventName.includes('video_data') && !eventName.includes('telemetry') && !eventName.includes('config')) {
        const [isValid, validationErrors] = websocketMessageValidator.validateOutgoingMessage(eventName, payload);
        
        if (!isValid) {
          console.warn(`WebSocketService: Validation warning for outgoing message ${eventName}:`, validationErrors);
          // Continue anyway - don't block the message
        }
      }
      
      // Sanitize the payload to prevent injection attacks
      const sanitizedPayload = websocketMessageValidator.sanitizeMessagePayload(payload);
      
      // Handle Socket.io connection
      if (this.socket && this.connectionType === ConnectionType.SOCKET_IO) {
        if (!this.connected) {
          console.error('Cannot send message: Socket.io is not connected');
          return false;
        }
        
        this.socket.emit(eventName, sanitizedPayload);
        return true;
      }
      
      // Handle native WebSocket connection
      if (!this.nativeWs || this.connectionType !== ConnectionType.NATIVE_WEBSOCKET) {
        console.error('Cannot send message: No native WebSocket connection');
        return false;
      }
      
      if (this.nativeWs.readyState !== WebSocket.OPEN) {
        console.error('Cannot send message: WebSocket is not open');
        return false;
      }
      
      const message = JSON.stringify({ type: eventName, data: sanitizedPayload });
      this.nativeWs.send(message);
      return true;
    } catch (error) {
      console.error(`WebSocketService: Error sending message ${eventName}:`, error);
      return false;
    }
  }

  // ... (rest of the code remains the same)

  /**
   * Disconnect from the WebSocket server
   */
  disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.connected = false;
    }
    
    if (this.nativeWs) {
      this.nativeWs.close();
      this.nativeWs = null;
    }
  }

  onTelemetry(callback: EventCallback<TelemetryData>): () => void {
    this.telemetryCallbacks.push(callback);
    return () => {
      this.telemetryCallbacks = this.telemetryCallbacks.filter(cb => cb !== callback);
    };
  }

  onSessionInfo(callback: EventCallback<SessionInfo>): () => void {
    this.sessionCallbacks.push(callback);
    return () => {
      this.sessionCallbacks = this.sessionCallbacks.filter(cb => cb !== callback);
    };
  }

  onCoachingInsights(callback: EventCallback<CoachingInsight[]>): () => void {
    this.coachingCallbacks.push(callback);
    return () => {
      this.coachingCallbacks = this.coachingCallbacks.filter(cb => cb !== callback);
    };
  }

  onDriverSkillAnalysis(callback: EventCallback<DriverSkillAnalysis>): () => void {
    this.skillAnalysisCallbacks.push(callback);
    return () => {
      this.skillAnalysisCallbacks = this.skillAnalysisCallbacks.filter(cb => cb !== callback);
    };
  }

  onCompetitorData(callback: EventCallback<CompetitorData[]>): () => void {
    this.competitorCallbacks.push(callback);
    return () => {
      this.competitorCallbacks = this.competitorCallbacks.filter(cb => cb !== callback);
    };
  }

  onStrategyData(callback: EventCallback<StrategyData>): () => void {
    this.strategyCallbacks.push(callback);
    return () => {
      this.strategyCallbacks = this.strategyCallbacks.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Register a callback for a custom event type
   * @param eventType The event type to listen for
   * @param callback Function to call when the event is received
   * @returns Function to unregister the callback
   */
  on(eventType: string, callback: EventCallback<any>): () => void {
    if (!this.eventCallbacks.has(eventType)) {
      this.eventCallbacks.set(eventType, []);
    }
    
    const callbacks = this.eventCallbacks.get(eventType) || [];
    callbacks.push(callback);
    this.eventCallbacks.set(eventType, callbacks);
    
    return () => {
      const updatedCallbacks = (this.eventCallbacks.get(eventType) || []).filter(cb => cb !== callback);
      this.eventCallbacks.set(eventType, updatedCallbacks);
    };
  }

  requestValidation(componentName: string, props: any): void {
    if ((!this.connected && this.connectionType === ConnectionType.SOCKET_IO) || 
        (this.nativeWs && this.nativeWs.readyState !== WebSocket.OPEN)) {
      console.error('Cannot request validation: WebSocket is not connected');
      return;
    }
    
    try {
      this.sendMessage('component_validation', {
        componentName,
        props
      });
    } catch (error) {
      console.error('Error requesting validation:', error);
    }
  }
  }
  
  /**
   * Register for validation summary events
   */
  onValidationSummary(callback: EventCallback<any>): () => void {
    this.validationCallbacks.push(callback);
    return () => {
      this.validationCallbacks = this.validationCallbacks.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Register for track position events
   */
  onTrackPosition(callback: EventCallback<any>): () => void {
    this.trackPositionCallbacks.push(callback);
    return () => {
      this.trackPositionCallbacks = this.trackPositionCallbacks.filter(cb => cb !== callback);
    };
  }
  
  /**
   * Register for video data events
   */
  onVideoData(callback: EventCallback<any>): () => void {
    this.videoDataCallbacks.push(callback);
    return () => {
      this.videoDataCallbacks = this.videoDataCallbacks.filter(cb => cb !== callback);
    };
  }

  // For testing/development with mock data
  emitMockTelemetry(data: TelemetryData): void {
    this.telemetryCallbacks.forEach(callback => callback(data));
  }

  emitMockSessionInfo(data: SessionInfo): void {
    this.sessionCallbacks.forEach(callback => callback(data));
  }

  emitMockCoachingInsights(data: CoachingInsight[]): void {
    this.coachingCallbacks.forEach(callback => callback(data));
  }

  emitMockDriverSkillAnalysis(data: DriverSkillAnalysis): void {
    this.skillAnalysisCallbacks.forEach(callback => callback(data));
  }

  emitMockCompetitorData(data: CompetitorData[]): void {
    this.competitorCallbacks.forEach(callback => callback(data));
  }

  emitMockStrategyData(data: StrategyData): void {
    this.strategyCallbacks.forEach(callback => callback(data));
  }
  
  emitMockTrackPosition(data: any): void {
    this.trackPositionCallbacks.forEach(callback => callback(data));
  }
  
  emitMockVideoData(data: any): void {
    this.videoDataCallbacks.forEach(callback => callback(data));
  }
  
  emitMockValidationSummary(data: any): void {
    this.validationCallbacks.forEach(callback => callback(data));
  }

  // Multi-driver event handlers
  onDriverUpdate(callback: EventCallback<DriverUpdateEvent>): () => void {
    this.driverUpdateCallbacks.push(callback);
    return () => {
      this.driverUpdateCallbacks = this.driverUpdateCallbacks.filter(cb => cb !== callback);
    };
  }

  onDriverList(callback: EventCallback<DriverListEvent>): () => void {
    this.driverListCallbacks.push(callback);
    return () => {
      this.driverListCallbacks = this.driverListCallbacks.filter(cb => cb !== callback);
    };
  }

  onHandoffRequest(callback: EventCallback<HandoffRequestEvent>): () => void {
    this.handoffRequestCallbacks.push(callback);
    return () => {
      this.handoffRequestCallbacks = this.handoffRequestCallbacks.filter(cb => cb !== callback);
    };
  }

  onHandoffResponse(callback: EventCallback<HandoffResponseEvent>): () => void {
    this.handoffResponseCallbacks.push(callback);
    return () => {
      this.handoffResponseCallbacks = this.handoffResponseCallbacks.filter(cb => cb !== callback);
    };
  }

  onSwitchDriver(callback: EventCallback<SwitchDriverEvent>): () => void {
    this.switchDriverCallbacks.push(callback);
    return () => {
      this.switchDriverCallbacks = this.switchDriverCallbacks.filter(cb => cb !== callback);
    };
  }

  onTeamMessage(callback: EventCallback<TeamMessageEvent>): () => void {
    this.teamMessageCallbacks.push(callback);
    return () => {
      this.teamMessageCallbacks = this.teamMessageCallbacks.filter(cb => cb !== callback);
    };
  }

  onRequestComparison(callback: EventCallback<RequestComparisonEvent>): () => void {
    this.requestComparisonCallbacks.push(callback);
    return () => {
      this.requestComparisonCallbacks = this.requestComparisonCallbacks.filter(cb => cb !== callback);
    };
  }

  onComparisonResult(callback: EventCallback<ComparisonResultEvent>): () => void {
    this.comparisonResultCallbacks.push(callback);
    return () => {
      this.comparisonResultCallbacks = this.comparisonResultCallbacks.filter(cb => cb !== callback);
    };
  }

  /**
   * Send a driver-specific telemetry event
   * @param driverId The ID of the driver
   * @param telemetryData The telemetry data to send
   */
  sendDriverTelemetry(driverId: string, telemetryData: any): void {
    this.sendMessage('telemetry', {
      driverId,
      ...telemetryData
    });
  }
  
  /**
   * Request telemetry data for a specific driver
   * @param driverId The ID of the driver
   * @param timeRange Optional time range for historical data
   */
  requestDriverTelemetry(driverId: string, timeRange?: { start: number; end: number }): void {
    this.sendMessage('request_telemetry', {
      driverId,
      timeRange
    });
  }
  
  /**
   * Send a team message
   * @param content The message content
   * @param senderId The ID of the sender
   * @param senderName The name of the sender
   * @param priority The message priority
   */
  sendTeamMessage(content: string, senderId: string, senderName: string, priority: 'normal' | 'high' | 'critical' = 'normal'): void {
    this.sendMessage('team_message', {
      message: {
        id: `msg-${uuidv4()}`,
        senderId,
        senderName,
        timestamp: Date.now(),
        content,
        priority
      }
    });
  }

  /**
   * Request a driver comparison
   * @param driverAId The ID of the first driver
   * @param driverBId The ID of the second driver
   */
  requestDriverComparison(driverAId: string, driverBId: string): string {
    const comparisonId = `${driverAId}_${driverBId}_${uuidv4()}`;
    
    this.sendMessage('request_comparison', {
      driverAId,
      driverBId,
      comparisonId
    });
    
    return comparisonId;
  }

  /**
   * Initiate a driver handoff
   * @param fromDriverId The ID of the current driver
   * @param toDriverId The ID of the target driver
   * @param notes Any notes for the handoff
   */
  initiateHandoff(fromDriverId: string, toDriverId: string, notes: string): string {
    const handoffId = uuidv4();
    
    this.sendMessage('handoff_request', {
      handoff: {
        id: handoffId,
        fromDriverId,
        toDriverId,
        notes,
        timestamp: Date.now(),
        status: 'pending'
      }
    });
    
    return handoffId;
  }

  /**
   * Respond to a handoff request
   * @param handoffId The ID of the handoff request
   * @param status The response status
   */
  respondToHandoff(handoffId: string, status: 'confirmed' | 'cancelled' | 'completed'): void {
    this.sendMessage('handoff_response', {
      handoffId,
      status
    });
  }

  /**
   * Switch the active driver
   * @param driverId The ID of the driver to switch to
   */
  switchDriver(driverId: string): void {
    this.sendMessage('switch_driver', {
      driverId
    });
  }
  
  // The requestValidation function is already defined above

  // Mock methods for testing multi-driver functionality
  emitMockDriverUpdate(data: DriverUpdateEvent): void {
    this.driverUpdateCallbacks.forEach(callback => callback(data));
  }

  emitMockDriverList(data: DriverListEvent): void {
    this.driverListCallbacks.forEach(callback => callback(data));
  }

  emitMockHandoffRequest(data: HandoffRequestEvent): void {
    this.handoffRequestCallbacks.forEach(callback => callback(data));
  }

  emitMockHandoffResponse(data: HandoffResponseEvent): void {
    this.handoffResponseCallbacks.forEach(callback => callback(data));
  }

  emitMockTeamMessage(data: TeamMessageEvent): void {
    this.teamMessageCallbacks.forEach(callback => callback(data));
  }

  emitMockComparisonResult(data: ComparisonResultEvent): void {
    this.comparisonResultCallbacks.forEach(callback => callback(data));
  }
}

// Singleton instance
export const webSocketService = new WebSocketService();
export default webSocketService;
