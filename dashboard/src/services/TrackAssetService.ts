import { tracks } from '../data/tracks/TrackRegistry';

export interface TrackAssetInfo {
    id: number;
    name: string;
    config_name?: string;
    assets?: {
        track_map?: string;
        [key: string]: any;
    };
}

class TrackAssetService {
    private trackIndex: Record<string, TrackAssetInfo> = {};
    private isInitialized = false;

    async initialize() {
        if (this.isInitialized) return;

        try {
            // Fetch the index file generated by sync-tracks
            // Note: The structure depends on what sync-tracks outputs. 
            // Based on package docs, it might output a tracks.json or similar.
            // We'll try to fetch 'assets/tracks/tracks.json' or iterate over directories if needed.
            // Looking at the package, it seems to output individual folder per track.
            // It also mentions `tracks.json` in the doc comment on `syncTrackAssets`.

            const response = await fetch('/assets/tracks/tracks.json');
            if (response.ok) {
                const data = await response.json();
                // Data is expected to be Record<string, TrackAsset>
                this.trackIndex = data;
                this.isInitialized = true;
                console.log('TrackAssetService initialized with ' + Object.keys(this.trackIndex).length + ' tracks.');
            } else {
                console.warn('TrackAssetService: Could not load tracks.json (Sync script not run/failed). Fallback to static registry only.');
            }
        } catch (error) {
            console.error('TrackAssetService: Error loading track assets', error);
        }
    }

    /**
     * Attempts to find a track map URL (SVG) for a given track name.
     * Falls back to undefined if not found.
     */
    getTrackMapUrl(trackName: string): string | undefined {
        if (!this.isInitialized) return undefined;

        // 1. Try exact ID match if trackName looks like an ID (unlikely from usual game data but possible)
        if (this.trackIndex[trackName]) {
            return this.getMapUrlFromAsset(this.trackIndex[trackName]);
        }

        // 2. Fuzzy Search by Name
        // This is expensive if we do it every frame, but fine for on-load.
        const normalizedQuery = trackName.toLowerCase().replace(/[^a-z0-9]/g, '');

        // Find key where name matches
        // The tracks.json structure from the package is likely: 
        // { "primary_key": { track_id, track_map, ... } }
        // We might need a separate info lookup if tracks.json doesn't contain names.
        // However, the `sync-track-assets` docs said it outputs `info.json` in each folder.
        // It also said "output directory will contain a `tracks.json` file with the track assets"

        // Let's assume for a moment we only have IDs in `tracks.json`.
        // In that case, we can't easily search by name without loading `track-info.json` as well.
        // Let's rely on what we can see.

        // If we assume keys are strings that might contain names or IDs.

        // If strictly ID based, we have a problem mapping "Silverstone" to ID without a map.
        // Dashboard app probably needs a "Tracks Metadata" file map.

        // For now, let's try to see if any key in trackIndex contains the name string
        // Or if the values have a name field.

        const match = Object.values(this.trackIndex).find((asset: any) => {
            // If asset has a name field check it
            if (asset.name && asset.name.toLowerCase().includes(normalizedQuery)) return true;
            return false;
        });

        if (match) {
            return this.getMapUrlFromAsset(match);
        }

        return undefined;
    }

    private getMapUrlFromAsset(asset: any): string | undefined {
        // The path in the json is likely relative or absolute on disk.
        // Since we serve it via public, we need to construct the URL.
        // If asset.track_map is "123/map.svg", then URL is "/assets/tracks/123/map.svg"

        if (asset.track_map) {
            // ensure it handles if it already has full path or not
            return `/assets/tracks/${asset.track_map}`;
        }
        return undefined;
    }

    // Helper to get from Static Registry
    getStaticTrackData(trackName: string) {
        // Try exact match
        if (tracks[trackName]) return tracks[trackName];

        // Try partial match (case insensitive)
        const key = Object.keys(tracks).find(k => k.toLowerCase().includes(trackName.toLowerCase()));
        if (key) return tracks[key];

        return null;
    }
}

export const trackAssetService = new TrackAssetService();
